{$I ../data_bases/AnimDyom.txt}
{$I ../data_bases/AnimDyos.txt}
{$I ../data_bases/Weapon_GetModelID.txt}
{$I ../data_bases/LoadSpecialActor.txt}

{$I ../utils/CustomSkin4.txt}
{$I ../utils/Math.txt}
{$I ../utils/InputNumberAndroid.txt}
{$I ../utils/InputNumberPC.txt}
{$I ../utils/InputTextAndroid.txt}

:Aplicated
	Text.ClearHelp()
	Text.PrintHelp('M0000DX')
return

:Disable
	Text.ClearHelp()
	Text.PrintHelp('M0000DV')
return

:Enable
	Text.ClearHelp()
	Text.PrintHelp('M0000DW')
return

:JustPC
	Text.ClearHelp()
	Text.PrintHelp('M000004')
return

:JustAndroid
	Text.ClearHelp()
	Text.PrintHelp('M0000PN')
return

:ComingSoon
	Text.ClearHelp()
	Text.PrintHelp('M000008')
return

:setMenuTrue
	08EE: set_panel hPanel column 1 row 0@ text_1number GXT 'M0000TV' number 0  // ~g~1
return
:setMenuFalse
	08EE: set_panel hPanel column 1 row 0@ text_1number GXT 'M0000TU' number 0  // ~r~0
return
:setMenuTrueA
    Enable()
	08EE: set_panel hPanel column 1 row _SELECTED text_1number GXT 'M0000TV' number 0  // ~g~1
return
:setMenuFalseA
    Disable()
	08EE: set_panel hPanel column 1 row _SELECTED text_1number GXT 'M0000TU' number 0  // ~g~1
return
:setMenuClear
	Menu.Remove(hPanel)
	Menu_Display_Show()
return


:Player_GetLastPosition
	Actor.GetPositionAndOffset(tempvar_X_coord, tempvar_Y_coord, tempvar_Z_coord, hPlayer, 0.0, 0.0, -1.0)
	tempvar_Angle = Actor.Angle(hPlayer)
	Interior.GetActive(Active_Interior)   
return

:Player_RemindPosition
    Actor.SetPosition(hPlayer, tempvar_X_coord, tempvar_Y_coord, tempvar_Z_coord)
    Actor.Angle(hPlayer) = tempvar_Angle
	Interior.SetVisible(Active_Interior)
	Actor.SetLinkInInterior(hPlayer) = Active_Interior
return

:GiveWeaponAndAmmo {
		0@ - int  : Actor
		1@ - int  : Model ID
		2@ - int  : Weapon ID
		3@ - int  : Ammo
	}
	FixUpdate()
	Model.Load(1@)
	repeat
		Wait0()
	until Model.Available(1@)

	if 0@ >= 0
	then 
		Actor.setGiveWeaponAndAmmo(0@, 2@, 3@)
	else
		// pasar valor a absoluto
		// 0@ es el offset del buffer de actores
		// 0@ = bufferActor[0@]
		// Actor.SetGiveWeaponAndAmmo($Actor($indActor,255i), 2@, 3@)
		nop
	end
	
	Model.Release(1@)
ret 0


:AnimarJugador
	if Menu_Enter()
    then
    	ResetAnimPlayer()
        if bit_is_true PLAYER_FLAGS PLAYER_PROP_COLISION
        then Task.PlayAnimSecondary(hPlayer, IFP_ANIM, IFP_FILE, 1000.0, true, false, false, false, -1)
        else Task.PlayAnim(hPlayer, IFP_ANIM, IFP_FILE, 1000.0, true, false, false, false, -1)
        end
        Menu_Take_Selection()
    end
    Text.ClearHelp()
    if Para1()
    then
    	ResetAnimPlayer()
        Task.PlayAnim(hPlayer, IFP_ANIM, IFP_FILE, 1000.0, true, false, false, false, -1)
        Text.PrintHelp('M0000RM')
        Frenar1()
    end
    if Para2()
    then
    	ResetAnimPlayer()
        Task.PlayAnimSecondary(hPlayer, IFP_ANIM, IFP_FILE, 1000.0, true, false, false, false, -1)
        Text.PrintHelp('M0000RN')
        Frenar2()
    end
    if Para3()
    then
    	ResetAnimPlayer()
        Task.PlayAnim(hPlayer, IFP_ANIM, IFP_FILE, 1000.0, true, true, true, false, -1)
        Text.PrintHelp('M0000FV')
        Frenar3()
    end
    if Para4()
    then
    	ResetAnimPlayer()
        Task.DieNamedAnim(hPlayer, IFP_ANIM, IFP_FILE, 1000.0, -1)
        Text.PrintHelp('M00000}')
        Frenar3()
    end
return

:ResetAnimPlayer
	Actor.SetClearTasksImmediately(hPlayer)
	Actor.SetClearTasks(hPlayer)
return


:ShowData
	FixUpdate()

	if bit_is_false DYOS_FLAGS CAMARA_CINEMATICA
	then
		// Credits of code block edited to Vital
		// https://www.youtube.com/watch?v=vlXTQCVVb3Y&list=PLFAE331B20083DBCC
		if CURRENT_PLATFORM == __PLATFORM_ANDROID
		then
			//armour
		    0@ = Actor.GetArmour(hPlayer) 
		    if 0@ > 0
		    then
		        Text.SetRightJustify(true)
		        call @PrintNumberColor 8 633.0 39.0 'M0000DN' 0@ 0x96 0x96 0x96 0xff
		    end
		    //health
		    1@ = Actor.GetHealth(hPlayer)   
		    if 1@ > 0
		    then
		        Text.SetRightJustify(true)
		        if 0@ > 0 //armour
		        then
		        	if CURRENT_PLATFORM  == __PLATFORM_WINDOWS
		        	then call @PrintNumberColor 8 603.0 39.0 'M0000DN' 1@ 0xd3 0x2f 0x2f 0xff
		        	else call @PrintNumberColor 8 600.0 39.0 'M0000DN' 1@ 0xd3 0x2f 0x2f 0xff
		        	end
		        else call @PrintNumberColor 8 633.0 39.0 'M0000DN' 1@ 0xd3 0x2f 0x2f 0xff
		        end
		    end
		    //money 
		    0@ = Player.GetMoney(0)
		    Text.SetRightJustify(true)
		    Text.SetOutline(1, 0, 0, 0, 200)
		    Text.SetFont(Font.Pricedown)
		    Text.SetScale(0.45, 1.8)
		    if 0@ > 0
		    then
		        Text.SetColor(72, 140, 62, 255)
		    else
		        if 0@ == 0
		        then Text.SetColor(200, 200, 200, 255)
		        else Text.SetColor(255, 0, 0, 255)
		        end
		    end
		    Text.DisplayWithNumber(633.0, 23.0, 'M0000MC', 0@)
		    //time 
		    00BF: 0@ = current_time_hours, 1@ = current_time_minutes
		    0342: set_text_draw_centered 1
		    0093: 2@ = integer 0@ to_float
		    0093: 3@ = integer 1@ to_float
		    3@ /= 60.0 //convert minutes: 60 min is 1
		    005B: 2@ += 3@  // (float) add converted minutes to hours
		    2@ *= 7.5 //convert to angle: 12:00 is 90°, whose sine is 1
		    02F6: 2@ = sine 2@ // (float) get sine
		    2@ *= 170.0 //max is 1, multiply by 170, which is max added colour value   
		    0092: 2@ = float 2@ to_integer
		    2@ += 70 //70 is min colour value in order not to make the text too dark
		    0340: set_text_draw_RGBA 2@ 2@ 255 255
		    Text.SetOutline(1, 0, 0, 0, 200)
		    Text.SetFont(Font.Pricedown)
		    Text.SetScale(0.45, 1.8)
		    if 1@ > 9
		    then 045B: draw_text_2numbers 610.0 7.0 GXT 'M0000MD' numbers 0@ 1@  // ~1~:~1~
		    else 045B: draw_text_2numbers 610.0 7.0 GXT 'M0000OL' numbers 0@ 1@  // ~1~:0~1~
		    end
		    
		    0@ = Player.GetWantedLevel(hChar)
		    if 0@ > 0
		    then
			    Text.SetFont(Font.Gothic)
				Text.SetColor(0xff,0xc1,0x07, 0xff)
			    Text.SetOutline(1, 0, 0, 0, 200)
			    Text.SetScale(0.45, 1.8)
		    	Text.SetRightJustify(true)
				Text.DisplayWithNumber(633.0, 56.0,'M0000ST', 0@)
			end
		else
	    	if bit_is_true DYOS_FLAGS DEBUG_MODE
	    	then
				float 3@ = DEBUG_CURSOR_X
				float 4@ = DEBUG_CURSOR_Y

				float 0@
				float 1@
				Mouse.GetMovement(0@, 1@)
				0@ /= 3.0
				1@ /= 3.0
				3@ += 0@
				4@ -= 1@

				if 3@ < 0.0
				then 3@ = 0.0
				end
				if 4@ < 0.0
				then 4@ = 0.0
				end
				if 3@ > 640.0
				then 3@ = 640.0
				end
				if 4@ > 480.0
				then 4@ = 480.0
				end

				Math.FloatToInt_LsL(3@,3@)
				Math.FloatToInt_LsL(4@,4@)
				Math.FloatToInt_LsL(0@,0@)
				Math.FloatToInt_LsL(1@,1@)

				//Cursor.X ~1~
				Text.SetWrapX(630.0)
				Text.SetRightJustify(true)
				Text.SetOutline(1, 0, 0, 0, 200)
				Text.SetFont(Font.Pricedown)
				Text.SetScale(0.45, 1.8)
				Text.DisplayWithNumber(633.0, 220.0, 'M0000VO', 3@)
				//Cursor.Y ~1~
				Text.SetWrapX(630.0)
				Text.SetRightJustify(true)
				Text.SetOutline(1, 0, 0, 0, 200)
				Text.SetFont(Font.Pricedown)
				Text.SetScale(0.45, 1.8)
				Text.DisplayWithNumber(633.0, 235.0, 'M0000VP', 4@)
				//Offset.X ~1~
				Text.SetWrapX(630.0)
				Text.SetRightJustify(true)
				Text.SetOutline(1, 0, 0, 0, 200)
				Text.SetFont(Font.Pricedown)
				Text.SetScale(0.45, 1.8)
				Text.DisplayWithNumber(633.0, 250.0, 'M0000UQ', 0@)
				//Offset.Y ~1~
				Text.SetWrapX(630.0)
				Text.SetRightJustify(true)
				Text.SetOutline(1, 0, 0, 0, 200)
				Text.SetFont(Font.Pricedown)
				Text.SetScale(0.45, 1.8)
				Text.DisplayWithNumber(633.0, 265.0, 'M0000UR', 1@)

				3@ = Math.IntToFloat_LsL(3@)
				4@ = Math.IntToFloat_LsL(4@)
				
				Txd.Remove()
				Txd.Load('LD_BEAT')
				Txd.LoadSprite("upl", 1)

				Txd.DrawSprite(1,3@,4@,15.0,15.0,255,128,255,255) 

				DEBUG_CURSOR_X = 3@
				DEBUG_CURSOR_Y = 4@
				if and
					3@ >= 36.0
					3@ <= 180.0
					4@ >= 160.0
					4@ <= 420.0
				then
					int 0@ = 0
					float 1@ = 204.0
					float 2@ = 214.0
					while 0@ < 12
						if and
							4@ >= 1@
							4@ <= 2@
						then
							_SELECTED = 0@
						end
						1@ += 16.0
						2@ += 16.0
						0@ += 1
					end

				    Mouse.GetMovement(0@, 1@)
				    1@ *= -1.0
					if or
						not 0@ == 0.0
						not 1@ == 0.0
					then
						Menu.SetActiveItem(hPanel, _SELECTED)
					end
				end
	    	end
		end

        if bit_is_true DYOS_FLAGS DEBUG_MODE
        then
		    //coords
		    Actor.GetPosition(hPlayer,0@,1@,2@)
			float 0@ = 0@
		    PrintFloatXY()
			Text.DisplayWith2Numbers(633.0, 130.0, 'M0000SK', 1@, 2@)
		    Actor.GetPosition(hPlayer,1@,0@,2@)
			float 0@ = 0@
		    PrintFloatXY()
			Text.DisplayWith2Numbers(633.0, 145.0, 'M0000SL', 1@, 2@)
		    if Actor.IsDriving(hPlayer)
		    then Actor.GetPosition(hPlayer,1@,2@,0@)
		    else Actor.GetPositionAndOffset(1@,2@,0@,hPlayer,0.0,0.0,-1.0)
		    end
			float 0@ = 0@
		    PrintFloatXY()
			Text.DisplayWith2Numbers(633.0, 160.0, 'M0000SM', 1@, 2@)
		    //angle
		    0@ = Actor.GetAngle(hPlayer)
		    Math.FloatToInt_LsL(0@,0@)
			Text.SetWrapX(630.0)
		    Text.SetRightJustify(true)
		    Text.SetOutline(1, 0, 0, 0, 200)
		    Text.SetFont(Font.Pricedown)
		    Text.SetScale(0.45, 1.8)
			Text.DisplayWithNumber(633.0, 175.0, 'M0000SN', 0@)
			//interior
		    Interior.GetActive(0@)
			Text.SetWrapX(630.0)
		    Text.SetRightJustify(true)
		    Text.SetOutline(1, 0, 0, 0, 200)
		    Text.SetFont(Font.Pricedown)
		    Text.SetScale(0.45, 1.8)
			Text.DisplayWithNumber(633.0, 190.0, 'M0000SO', 0@)
			//modelo
		    0@ = Actor.GetModel(hPlayer)
			Text.SetWrapX(630.0)
		    Text.SetRightJustify(true)
		    Text.SetOutline(1, 0, 0, 0, 200)
		    Text.SetFont(Font.Pricedown)
		    Text.SetScale(0.45, 1.8)
			Text.DisplayWithNumber(633.0, 205.0, 'M0000SU', 0@)
		end
	end
ret 0

:PrintFloatXY
	{
		0@  : num
	}
	Math.FloatToInt_LsL(1@, 0@)
	0087: 2@ = 0@ // (float)
	2@ *= 1000.0
	if 2@ < 0
	then 2@ *= -1.0
	end

	while 2@ > 100000.0
		2@ -= 100000.0
	end
	while 2@ > 10000.0
		2@ -= 10000.0
	end
	while 2@ > 5000.0
		2@ -= 5000.0
	end
	while 2@ > 2000.0
		2@ -= 2000.0
	end
	while 2@ > 1000.0
		2@ -= 1000.0
	end

	Math.FloatToInt_LsL(2@, 2@)
	Text.SetWrapX(630.0)
    Text.SetRightJustify(true) 
    //Text.SetColor(0xd3, 0x2f, 0x2f, 0xff)
    Text.SetOutline(1, 0, 0, 0, 200)
    Text.SetFont(Font.Pricedown)
    Text.SetScale(0.45, 1.8)
return

:PrintNumberColor
	// 0@ : coord.x
	// 1@ : coord.y
	// 2@ : string
	// 3@ : number
	// 4@ : color.r
	// 5@ : color.g
	// 6@ : color.b
	// 7@ : color.a
    Text.SetColor(4@,5@,6@,7@)
    Text.SetOutline(1, 0, 0, 0, 200)
    Text.SetFont(Font.Pricedown)
    Text.SetScale(0.45, 1.8)
    string_format 30@s = "%s" 2@
    Text.DisplayWithNumber(0@, 1@, 30@s, 3@)
ret 0


:Change_Debug_Mode
	if VK_Debug()
	then
		if bit_is_true DYOS_FLAGS DEBUG_MODE
		then bit_set_false DYOS_FLAGS DEBUG_MODE
		else bit_set_true DYOS_FLAGS DEBUG_MODE
		end
	end
return

:MemoryWrite
	int 0@ // addr
	int 1@ // size
	int 2@ // value

    0DD5: CURRENT_PLATFORM = get_platform
    if CURRENT_PLATFORM == __PLATFORM_WINDOWS
    then Memory.Write(0@, 1@, 2@, false)
    else 0DD9: write_mem_addr 0@ value 2@ size 1@ add_ib 0 protect 0
    end	
ret 0

:MemoryRead
	int 0@ // addr
	int 1@ // size

	int 2@ // value

    0DD5: CURRENT_PLATFORM = get_platform
    if CURRENT_PLATFORM == __PLATFORM_WINDOWS
    then 2@ = Memory.Read(0@, 1@, false)
    else 0DD8: 2@ = write_mem_addr 0@ size 1@ add_ib 0
    end
ret 1 2@




/*
:VehicleDefinidoInferior
	$indAuto--
	:Bucle_VehicleDefinidoInferior
	if $indAuto < 1
	then $indAuto = $numAutos
	end
	if not Car.Defined($Auto($indAuto,255i))
	then
		$indAuto--
		jump @Bucle_VehicleDefinidoInferior
	end
return

:VehicleDefinidoSuperior
	$indAuto++
	if $indAuto > $numAutos
	then $indAuto = 1
	end
	:Bucle_VehicleDefinidoSuperior
	if not Car.Defined($Auto($indAuto,255i))
	then
		$indAuto++
		jump @Bucle_VehicleDefinidoSuperior
	end
return

:ObjectDefinidoInferior
	$indObjeto--
	:Bucle_ObjectDefinidoInferior
	if $indObjeto < 1
	then $indObjeto = $numObjetos
	end
	if not Object.Defined($Objeto($indObjeto,255i))
	then
		$indObjeto--
		jump @Bucle_ObjectDefinidoInferior
	end
return

:ObjectDefinidoSuperior
	$indObjeto++
	if $indObjeto > $numObjetos
	then $indObjeto = 1
	end
	:Bucle_ObjectDefinidoSuperior
	if not Object.Defined($Objeto($indObjeto,255i))
	then
		$indObjeto++
		jump @Bucle_ObjectDefinidoSuperior
	end
return

:ActorDefinidoInferior
	$indActor--
	:Bucle_ActorDefinidoInferior
	if $indActor < 1
	then $indActor = $numActores
	end
	if not Actor.Defined($Actor($indActor,255i))
	then
		$indActor--
		jump @Bucle_ActorDefinidoInferior
	end
return

:ActorDefinidoSuperior
	$indActor++
	if $indActor > $numActores
	then $indActor = 1
	end
	:Bucle_ActorDefinidoSuperior
	if not Actor.Defined($Actor($indActor,255i))
	then
		$indActor++
		jump @Bucle_ActorDefinidoSuperior
	end
return
*/

:Search_Slot_Available_Actor
	FixUpdate()

	int 0@ = 0 // indice temporal

	while 0@ <= SM_NUM_ACTORS
		SM_INDEX_ACTORS = 0@

		call @Array_Actor_Get 2 SM_INDEX_ACTORS B_ACTOR_HANDLE result SM_ACTOR
		if Actor.Defined(SM_ACTOR)
		then
			0@ += 1  // slot ocupado → probar siguiente
		else
			0@ *= -1 // slot libre encontrado → marcar con negativo
			break
		end
	end

	if 0@ < 0 // Se hayo un slot libre
	then
		0@ *= -1 // restaurar índice real del slot libre
	else
		// no había huecos → usar nuevo slot

		SM_INDEX_ACTORS = SM_NUM_ACTORS
		SM_NUM_ACTORS++
		SM_INDEX_ACTORS++
	end

ret 1 0@

/** Ejemplos:
*	| SM_INDEX_ACTORS = 0
*	| call @Array_Actor_Get 2 SM_INDEX_ACTORS B_ACTOR_HANDLE result 0@
*	| 0@ = Array_Actor_Get(SM_INDEX_ACTORS, B_ACTOR_HANDLE)
*/
:Array_Actor_Get
	// 0@ col (index)
	// 1@ row (property)

	0@ *= 4  // para desplazarse de 4 bytes
	1@ *= 19 // para desplazarse entre los props

	2@ = 0@ + 1@
	FixUpdate()

    2401: read_memory_with_offset SM_BUFFER_ACTORS offset 2@ size 4 store_to 20@
ret 1 20@

/** Ejemplos:
*	| SM_INDEX_ACTORS = 0
*	| call @Array_Actor_Set 3 SM_INDEX_ACTORS B_ACTOR_HANDLE value 0@
*	| Array_Actor_Set(SM_INDEX_ACTORS, B_ACTOR_HANDLE) = 0@
*/
:Array_Actor_Set
	// 0@ col (index)
	// 1@ row (property)
	// 2@ value (any)

	0@ *= 4  // para desplazarse de 4 bytes
	1@ *= 19 // para desplazarse entre los props

	20@ = 0@ + 1@
	FixUpdate()

	2402: write_memory_with_offset SM_BUFFER_ACTORS offset 20@ size 4 value 2@
ret 0

:ActorDefinidoSuperior
	FixUpdate()
	if SM_NUM_ACTORS > 0
	then
		:Bucle_ActorDefinidoSuperior
		
		call @Array_Actor_Get 2 SM_INDEX_ACTORS B_ACTOR_HANDLE result SM_ACTOR

		if or
			SM_ACTOR == 0
			not Actor.Defined(SM_ACTOR)
		then
			SM_INDEX_ACTORS++
			if SM_INDEX_ACTORS > SM_NUM_ACTORS
			then
				SM_NUM_ACTORS = 0
				SM_INDEX_ACTORS = 0
				SM_ACTOR = 0
			else
				jump @Bucle_ActorDefinidoSuperior
			end
		end
	else
		SM_NUM_ACTORS = 0
		SM_INDEX_ACTORS = 0
		SM_ACTOR = 0
	end
return

:iluminar_al_jugador
	call @getMagicPointer 0 30@
	if FOCUS_LIGHT_MODE == FOCUS_LIGHT_NIGHT
	then
		Actor.GetPositionAndOffset(__Af, __Bf, __Cf, hPlayer, 1.0, 0.0, 1.0)
		Fx.DrawLightWithRange(__Af, __Bf, __Cf, 255, 0 ,0,10.0)
		Actor.GetPositionAndOffset(__Af, __Bf, __Cf, hPlayer, -1.0, 0.0, 1.0)
		Fx.DrawLightWithRange(__Af, __Bf, __Cf, 0,0, 255,10.0)
		Actor.GetPositionAndOffset(__Af, __Bf, __Cf, hPlayer, 0.0, 0.0, 0.0)
		Fx.DrawShadow(SHADOW_TEXTURE_TYPE.EXPLOSION, __Af, __Bf, __Cf, 0xaa, 0x00, 0xff, 0.0, 1.0, 0xCC)  
	end

	if FOCUS_LIGHT_MODE == FOCUS_LIGHT_DAY
	then
		Actor.GetPositionAndOffset(__Af, __Bf, __Cf, hPlayer, 0.0, 1.0, 1.0)
		Fx.DrawLightWithRange(__Af, __Bf, __Cf, 255, 255,255,10.0)
		Actor.GetPositionAndOffset(__Af, __Bf, __Cf, hPlayer, 0.0, -1.0, 1.0)
		Fx.DrawLightWithRange(__Af, __Bf, __Cf, 255, 255,255,10.0)
		Actor.GetPositionAndOffset(__Af, __Bf, __Cf, hPlayer, 0.0, 0.0, 0.0)
		Fx.DrawShadow(SHADOW_TEXTURE_TYPE.EXPLOSION, __Af, __Bf, __Cf, 0xff, 0xff, 0xff, 0.0, 1.0, 0x77)  
	end

	28@ = 90  // VK.Z
	29@ = 122 // Minus gray
	if VK_PressedOnce()
	then
		if FOCUS_LIGHT_MODE >= 2
		then FOCUS_LIGHT_MODE = FOCUS_LIGHT_NONE
		else FOCUS_LIGHT_MODE++
		end
	end
ret 0

:recuperarSkinDelPlayer
	int 15@ = MODEL_PLAYER

	if 15@ >= 0
	then
		Model.Load(15@)
		repeat
			Wait0()
		until Model.Available(15@)
		Player.SetModel(hChar,15@)
	else
		if 15@ >= -500
		then
			15@ -= 500
			LoadSpecialActor()
		else
			15@ *= -1
			15@ -= 500
			call @CustomSkin4 1 15@
		end

		repeat
			Wait0()
		until SpecialActor.Available(1)
		Player.SetModel(hChar,#SPECIAL01)
	end
return


:MiniSCM_ActionsAvailables
    // son 12 elementos
    int 0@, 1@, 2@, 3@, 4@, 5@, 6@, 7@, 8@, 9@, 10@, 11@

    call @getMagicPointer 0 30@
    switch _SELECTED
	    case 0
          DYOS_HELP_ID = 0@
	    case 1
          DYOS_HELP_ID = 1@
	    case 2
          DYOS_HELP_ID = 2@
	    case 3
          DYOS_HELP_ID = 3@
	    case 4
          DYOS_HELP_ID = 4@
	    case 5
          DYOS_HELP_ID = 5@
	    case 6
          DYOS_HELP_ID = 6@
	    case 7
          DYOS_HELP_ID = 7@
	    case 8
          DYOS_HELP_ID = 8@
	    case 9
          DYOS_HELP_ID = 9@
	    case 10
          DYOS_HELP_ID = 10@
	    case 11
          DYOS_HELP_ID = 11@
		default
	      nop
	  end
ret 0


/**
* Use:
*	|
*	|	call @RenderLine 4 of_xy 0.0 0.0 to_xy 20.0 20.0 results 0@ 1@ length 2@ angle 3@
*	|	074B: draw_sprite SPRITESLOT offset 0@ 1@ width 2@ height 1.0 angle 3@
*	|
*/
/*
:RenderLine
// ---------------------------------------
// Puntos A (x1,y1) y B (x2,y2)
// ---------------------------------------
float 0@ // x1
float 1@ // y1
float 2@ // x2
float 3@ // y2

// ---------------------------------------
// delta = B - A
// ---------------------------------------
4@ = 2@ - 0@    // dx
5@ = 3@ - 1@    // dy

// ---------------------------------------
// length = sqrt(dx*dx + dy*dy)
// usando pow
// ---------------------------------------
6@ = 4@
6@ *= 4@        // dx²

7@ = 5@
7@ *= 5@        // dy²

6@ += 7@        // dx² + dy²

if 6@ < 0.0     // seguridad (muy importante)
then
    6@ = 0.0
end

0AEE: 6@ = 6@ pow 0.5   // sqrt → length

// ---------------------------------------
// centro = (A + B) / 2
// ---------------------------------------
7@ = 0@ + 2@
7@ *= 0.5       // cx

8@ = 1@ + 3@
8@ *= 0.5       // cy

// ---------------------------------------
// ángulo = atan2(dy, dx) en grados
// ---------------------------------------
0A8D: 9@ = atan2 5@ 4@
9@ *= 57.29578

ret 3 coords_xy 7@ 8@ length 9@ angle 9@
*/